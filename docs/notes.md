SpecDFA and Span
==================

This report documents the definition,
components and scope of SpecDFA for Span.


## The partial list of analyses targeted by SpecDFA

1. **Live Variables**
1. Strongly Live Variables
1. **Constant Propagation**
1. **Reaching Definition**
1. **Interval/Range**
1. Parity/Even-Odd
1. **Sign**
1. **Points-to**
1. **Available Expressions**
1. Partially Available Expressions
1. Anticipable Expressions
1. Dominator

The bold ones are the analyses that we are targeting currently.


## Some in-built types in the system

Each type name denotes a set of values with a particular property.

1. Value Types
   1. Num
   1. Int
   1. Float
   1. Ptr

2. Entity Types
   1. Expr
      1. Var
      1. OpExpr
         1. BinOpExpr
         1. UnOpExpr

      All expression types can be prefixed with numeric types to form
      a combined type. E.g. NumVar denotes variables which are numeric,
      IntBinOpExpr denotes binary expressions with integer value.

   1. StmtId

3. Container Types
   1. Set
   2. Map
   3. Tuple -- comma separated type names enclosed in parantheses

## Predefined value sets in the system

1. Corresponding to each in-built type in the system,
there is a variable which can be assumed to contain
all the values possible in that type.
The name of these special variables are generated by prefixing
the type name with the word 'all'.
For example, `allExpr` is a set of all the expressions
of type `Expr`, `allNumVar` is a set of all the variables of numeric type.

2. `EmptySet` is a special value that denotes a set with no elements.
   Its polymorphic in its type, such that its type is determined by the context.

## Lattice properties, assumptions and notations

All lattices have the following properties,

1. Equality test can be done on the lattice values.
1. Partial Order macros
   1. `#SetSupset` -- a super-set is weaker
   1. `#SetSubset` -- a subset is weaker



## Example specifications

All these specifications have two forms of specifications

1. Short Specification  
      -- this is the shortest possbile specification that is sufficient.
2. Full  Specification
      -- this is the complete specification as seen by the system.
         It can be described by the user as a full specification too.

### Available Expressions Analysis

    % lattice -- short specification
    AvL       isa Lattice
    AvL       = AvL (Set Expr)
    AvL.po    = #SetSubset        % AvL.meet can be derived from AvL.po in this case
                % A string prefixed with `#` behaves like a macro,
                % with predefined meaning,
                % it helps expand the short specification to a full specification.

    % lattice -- full specification
    AvL     isa Lattice
    AvL     = AvL (Set Expr)
    AvL.top = AvL allExpr
    AvL.bot = AvL EmptySet

    AvL.po (AvL x) (AvL y)    = Set.subset x y

    AvL.meet (AvL x) (AvL y)  = AvL (Set.intersect x y)



### Constant Propagation

    % lattice -- short specification
    %   Component Lattice
    CpvL      isa  Lattice               % Cp value lattice
    CpvL      =   Top | Bot | CpvL Num
    CpvL.po x y     = False             % CpvL.meet can be derived from this 

    %   Overall Lattice
    CpL     isa  Lattice
    CpL     =   CpL (Map (NumVar, CpvL))
    %       All other details can be derived from this lattice specification.


    % lattice -- full specification
    %   Component Lattice
    CpvL      isa  Lattice              % Cp value lattice
    CpvL      =   Top | Bot | CpvL Num
    CpvL.top  =   Top
    CpvL.bot  =   Bot

    CpvL.po x y     = x == y
    CpvL.po Top _   = False
    CpvL.po _ Top   = True
    CpvL.po Bot _   = True
    CpvL.po _ Bot   = False
    CpvL.po x y     = False

    CpvL.meet Top y = y
    CpvL.meet x Top = x
    CpvL.meet Bot y = Bot
    CpvL.meet x Bot = Bot
    CpvL.meet (CpvL x) (CpvL y) | x == y    = CpvL x
                                | otherwise = Bot

    %   Overall Lattice
    CpL     isa  Lattice
    CpL     =   CpL (Map (NumVar, CpvL))
    CpL.top =   CpL (Map [(var, CpvL.top) | var <- allNumVar])
    CpL.bot =   CpL (Map [(var, CpvL.bot) | var <- allNumVar])

    CpL.po (CpL x) (CpL y) = all [CpvL.po val1 val2 
                                   | (v1, val1) <- x, (v2, val2) <- y,
                                      v1 == v2]

    CpL.meet (CpL x) (CpL y) = CpL (Map ([(v1, CpvL.meet val1 val2)
                                           | (v1, val1) <- x, (v2, val2) <- y,
                                              v1 == v2]))
                                            


### Live Variables

    % lattice -- short specification
    LiveL     isa  Lattice
    LiveL     =   LiveL (Set Var)
    LiveL.po  =   #SetSupset

    % lattice -- full specification
    LiveL     isa  Lattice
    LiveL     =   LiveL (Set Var)
    LiveL.top =   LiveL allVar
    LiveL.bot =   LiveL EmptySet

    LiveL.po (LiveL x) (LiveL y)    = Set.supset x y

    LiveL.meet (LiveL x) (LiveL y)  = LiveL (Set.union x y)


### Sign Analysis

    % lattice -- short specification
    SignL     isa  Lattice
    SignL     =   Top | Bot | Neg | Pos | Zero | NegZero | PosZero
    SignL.po  NegZero Neg   = True
    SignL.po  NegZero Zero  = True
    SignL.po  PosZero Pos   = True
    SignL.po  PosZero Zero  = True

    SignML    isa  Lattice
    SignML    =   SignML (Map (NumVar, SignL))


    % lattice -- full specification
    SignL     isa  Lattice
    SignL     =   Top | Bot | Neg | Pos | Zero | NegZero | PosZero

    SignL.po  x       y     | x == y = True
    SignL.po  Bot     _     = True
    SignL.po  _       Top   = True
    SignL.po  NegZero Neg   = True
    SignL.po  NegZero Zero  = True
    SignL.po  PosZero Pos   = True
    SignL.po  PosZero Zero  = True
    SignL.po  _       _     = False

    SignL.meet x        y     | SignL.po x y = x
                              | SignL.po y x = y
    SignL.meet NegZero  PosZero = Bot
    SignL.meet PosZero  NegZero = Bot
    SignL.meet Pos      Zero    = PosZero
    SignL.meet Zero     Pos     = PosZero
    SignL.meet Neg      Zero    = NegZero
    SignL.meet Zero     Neg     = NegZero

    %   Overall Lattice
    SignML     isa  Lattice
    SignML     =   SignML (Map (NumVar, SignL))
    SignML.top =   SignML (Map [(var, SignL.top) | var <- allNumVar])
    SignML.bot =   SignML (Map [(var, SignL.bot) | var <- allNumVar])

    SignML.po (SignML x) (SignML y) = all [SignL.po val1 val2 
                                           | (v1, val1) <- x, (v2, val2) <- y,
                                             v1 == v2]

    SignML.meet (SignML x) (SignML y) =
         SignML ( Map ([(v1, SignL.meet val1 val2)
                         | (v1, val1) <- x, (v2, val2) <- y,
                           v1 == v2]
   


### Range/Interval Analysis

    % ---- short specification ----
    
    % lower limit lattice
    LoL     isa Lattice
    LoL     = PosInfinity | NegInfinity | LoL Int
    LoL.top = PosInfinity
    LoL.bot = NegInfinity
    LoL.po (LoL x) (LoL y)  | x <= y = True
                            | otherwise = False
    
    % higher limit lattice
    HiL     isa Lattice
    HiL     = PosInfinity | NegInfinity | HiL Int
    HiL.top = NegInfinity
    HiL.bot = PosInfinity
    HiL.po (HiL x) (HiL y)  | x >= y = True
                            | otherwise = False
    
    % range lattice
    RaL     isa Lattice
    RaL     = RaL (Tuple (LoL, HiL)) 
    
    % overall lattice
    V_RaL   isa Lattice
    V_RaL   = V_RaL (Map (NumVar, RaL))



## References
1. Haskell (<http://learnyouahaskell.com/chapters>)
2. Hoopl Framework (<https://hackage.haskell.org/package/hoopl>)
3. Hoopl Paper (<http://research.microsoft.com/en-us/um/people/simonpj/Papers/c--/hoopl-haskell10.pdf>)
4. TODO: add Prof. Uday's web page link to SpecDFA examples.


